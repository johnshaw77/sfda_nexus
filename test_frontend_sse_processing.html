<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>前端 SSE 處理測試</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .container {
        border: 1px solid #ddd;
        padding: 20px;
        margin: 10px 0;
        border-radius: 5px;
      }
      .thinking-content {
        background-color: #f0f8ff;
        border-left: 4px solid #007bff;
        padding: 10px;
        margin: 10px 0;
        white-space: pre-wrap;
      }
      .message-content {
        background-color: #f9f9f9;
        padding: 10px;
        margin: 10px 0;
        white-space: pre-wrap;
      }
      .log {
        background-color: #f5f5f5;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
      }
      button {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
      }
      button:hover {
        background-color: #0056b3;
      }
      .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
      }
      .status.connecting {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
      }
      .status.connected {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
      }
      .status.error {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
      }
    </style>
  </head>
  <body>
    <h1>🧪 前端 SSE 處理測試</h1>

    <div class="container">
      <h2>控制面板</h2>
      <button onclick="startSSETest()">開始 SSE 測試</button>
      <button onclick="stopSSETest()">停止測試</button>
      <button onclick="clearLogs()">清除日誌</button>
    </div>

    <div class="container">
      <h2>連接狀態</h2>
      <div
        id="status"
        class="status">
        未連接
      </div>
    </div>

    <div class="container">
      <h2>思考內容</h2>
      <div
        id="thinking-content"
        class="thinking-content">
        等待思考內容...
      </div>
    </div>

    <div class="container">
      <h2>消息內容</h2>
      <div
        id="message-content"
        class="message-content">
        等待消息內容...
      </div>
    </div>

    <div class="container">
      <h2>調試日誌</h2>
      <div
        id="log"
        class="log"></div>
    </div>

    <script>
      let eventSource = null;
      let messageContent = "";
      let thinkingContent = "";
      let isAnimating = false;
      let isThinkingAnimating = false;

      function log(message) {
        try {
          const logDiv = document.getElementById("log");
          const timestamp = new Date().toLocaleTimeString();
          logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
          logDiv.scrollTop = logDiv.scrollHeight;

          // 同時輸出到控制台
          console.log(`[${timestamp}] ${message}`);
        } catch (error) {
          console.error("日誌記錄錯誤:", error);
        }
      }

      function updateStatus(status, className) {
        try {
          const statusDiv = document.getElementById("status");
          statusDiv.textContent = status;
          statusDiv.className = `status ${className}`;
          console.log("狀態更新:", status);
        } catch (error) {
          console.error("狀態更新錯誤:", error);
        }
      }

      function updateThinkingContent(content) {
        try {
          const thinkingDiv = document.getElementById("thinking-content");
          thinkingDiv.textContent = content || "等待思考內容...";
          console.log("思考內容更新:", content?.length || 0, "字符");
        } catch (error) {
          console.error("思考內容更新錯誤:", error);
        }
      }

      function updateMessageContent(content) {
        try {
          const messageDiv = document.getElementById("message-content");
          messageDiv.textContent = content || "等待消息內容...";
          console.log("消息內容更新:", content?.length || 0, "字符");
        } catch (error) {
          console.error("消息內容更新錯誤:", error);
        }
      }

      // 打字機動畫效果
      function animateTyping(targetContent, currentContent = "") {
        if (isAnimating) {
          console.log("動畫正在進行中，跳過");
          return;
        }

        console.log(
          "開始打字機動畫:",
          currentContent.length,
          "→",
          targetContent.length
        );
        isAnimating = true;
        let currentIndex = currentContent.length;

        const typeNextChar = () => {
          try {
            if (currentIndex < targetContent.length) {
              const newContent = targetContent.substring(0, currentIndex + 1);
              updateMessageContent(newContent);
              currentIndex++;

              // 10-40ms 隨機延遲，模擬真實打字
              const delay = Math.random() * 30 + 10;
              setTimeout(typeNextChar, delay);
            } else {
              isAnimating = false;
              log("✅ 打字機動畫完成");
              console.log(
                "打字機動畫完成，最終內容長度:",
                targetContent.length
              );
            }
          } catch (error) {
            console.error("打字機動畫錯誤:", error);
            isAnimating = false;
          }
        };

        typeNextChar();
      }

      // 思考內容打字機動畫效果
      function animateThinkingTyping(targetContent, currentContent = "") {
        if (isThinkingAnimating) {
          console.log("思考動畫正在進行中，跳過");
          return;
        }

        console.log(
          "開始思考內容打字機動畫:",
          currentContent.length,
          "→",
          targetContent.length
        );
        isThinkingAnimating = true;
        let currentIndex = currentContent.length;

        const typeNextChar = () => {
          try {
            if (currentIndex < targetContent.length) {
              const newContent = targetContent.substring(0, currentIndex + 1);
              updateThinkingContent(newContent);
              currentIndex++;

              // 思考內容稍微快一點，5-20ms 延遲
              const delay = Math.random() * 15 + 5;
              setTimeout(typeNextChar, delay);
            } else {
              isThinkingAnimating = false;
              log("✅ 思考內容打字機動畫完成");
              console.log("思考內容動畫完成，最終長度:", targetContent.length);
            }
          } catch (error) {
            console.error("思考內容動畫錯誤:", error);
            isThinkingAnimating = false;
          }
        };

        typeNextChar();
      }

      function startSSETest() {
        try {
          console.log("=== 開始 SSE 測試 ===");
          log("🔄 開始 SSE 測試...");

          updateStatus("正在連接...", "connecting");

          // 重置內容
          messageContent = "";
          thinkingContent = "";
          updateThinkingContent("");
          updateMessageContent("");

          const token =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsImVtYWlsIjoiYWRtaW5AZXhhbXBsZS5jb20iLCJyb2xlIjoiYWRtaW4iLCJ0eXBlIjoiYWNjZXNzIiwiaWF0IjoxNzQ5OTgyMzE2LCJleHAiOjE3NTAwNjg3MTYsImF1ZCI6InNmZGEtbmV4dXMtdXNlcnMiLCJpc3MiOiJzZmRhLW5leHVzIn0.QSU8LdNi9a1oFJAu2wOn-Z80Ft-zVHnmEXdWo88PZG8";

          log("📡 發送 POST 請求到後端...");
          console.log(
            "發送請求到:",
            "http://localhost:3000/api/chat/conversations/21/messages/stream"
          );

          // 發送 POST 請求開始 SSE 流
          fetch(
            "http://localhost:3000/api/chat/conversations/21/messages/stream",
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": "application/json",
                Accept: "text/event-stream",
                "Cache-Control": "no-cache",
              },
              body: JSON.stringify({
                content: "3+3等於多少？如何學習編程？",
                agent_id: 1,
                model_id: 42, // qwen3:8b
                max_tokens: 4096,
                temperature: 0.7,
              }),
            }
          )
            .then((response) => {
              console.log("收到響應:", response.status, response.statusText);

              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                );
              }

              log("✅ SSE 連接建立成功，開始讀取流...");
              updateStatus("已連接", "connected");

              const reader = response.body.getReader();
              const decoder = new TextDecoder();
              let buffer = "";
              let eventCount = 0;

              function readStream() {
                reader
                  .read()
                  .then(({ done, value }) => {
                    if (done) {
                      console.log("=== SSE 流結束 ===");
                      log("📡 SSE 流結束");
                      updateStatus("連接已關閉", "error");
                      return;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split("\n");
                    buffer = lines.pop() || "";

                    let currentEventType = null;

                    for (const line of lines) {
                      if (line.startsWith("event: ")) {
                        currentEventType = line.slice(7).trim();
                        continue;
                      }

                      if (line.startsWith("data: ")) {
                        const jsonStr = line.slice(6).trim();

                        if (jsonStr && currentEventType) {
                          try {
                            eventCount++;
                            const data = JSON.parse(jsonStr);
                            console.log(
                              `事件 ${eventCount}:`,
                              currentEventType,
                              data
                            );
                            handleSSEEvent(data, currentEventType, eventCount);
                            currentEventType = null;
                          } catch (parseError) {
                            console.error(
                              "SSE 數據解析錯誤:",
                              parseError,
                              "原始數據:",
                              jsonStr
                            );
                            log(`❌ SSE 數據解析錯誤: ${parseError.message}`);
                          }
                        }
                      }
                    }

                    // 繼續讀取下一個數據塊
                    readStream();
                  })
                  .catch((error) => {
                    console.error("讀取流錯誤:", error);
                    log(`❌ 讀取流錯誤: ${error.message}`);
                    updateStatus("連接錯誤", "error");
                  });
              }

              readStream();
            })
            .catch((error) => {
              console.error("SSE 連接失敗:", error);
              log(`❌ SSE 連接失敗: ${error.message}`);
              updateStatus("連接失敗", "error");
            });
        } catch (error) {
          console.error("startSSETest 錯誤:", error);
          log(`❌ 測試啟動錯誤: ${error.message}`);
        }
      }

      function handleSSEEvent(data, eventType, eventNumber) {
        try {
          console.log(`處理事件 ${eventNumber}:`, eventType, data);
          log(`📨 事件 ${eventNumber}: ${eventType}`);

          switch (eventType) {
            case "user_message":
              log("👤 用戶消息已創建");
              break;

            case "assistant_message_created":
              log(`🤖 AI 消息已創建: ${data.assistant_message_id}`);
              break;

            case "stream_content":
              const contentLen = data.content?.length || 0;
              const thinkingLen = data.thinking_content?.length || 0;
              const deltaLen = data.content_delta?.length || 0;

              log(
                `🔄 流式內容更新: 內容=${contentLen}字符, 思考=${thinkingLen}字符, 增量=${deltaLen}字符`
              );
              console.log("stream_content 詳情:", {
                content: data.content,
                content_delta: data.content_delta,
                thinking: data.thinking_content?.substring(0, 100) + "...",
                contentLength: contentLen,
                deltaLength: deltaLen,
                thinkingLength: thinkingLen,
              });

              // 處理思考內容 - 修復：即時顯示思考內容，使用打字機動畫
              if (data.thinking_content !== undefined) {
                const newThinkingContent = data.thinking_content;
                const thinkingDelta = data.thinking_delta; // 新增的思考內容片段

                // 如果有思考內容增量，記錄詳情
                if (thinkingDelta) {
                  console.log("🧠 收到思考內容增量:", {
                    deltaLength: thinkingDelta.length,
                    deltaPreview: thinkingDelta.substring(0, 50) + "...",
                    totalLength: newThinkingContent.length,
                  });
                }

                // 如果思考內容有變化，使用打字機動畫顯示
                if (newThinkingContent !== thinkingContent) {
                  const currentThinkingContent = thinkingContent;

                  // 如果新內容比當前內容長，使用打字機動畫
                  if (
                    newThinkingContent.length > currentThinkingContent.length
                  ) {
                    log(
                      `🧠 準備思考內容打字機動畫: ${
                        currentThinkingContent.length
                      } → ${newThinkingContent.length} (+${
                        newThinkingContent.length -
                        currentThinkingContent.length
                      })`
                    );
                    animateThinkingTyping(
                      newThinkingContent,
                      currentThinkingContent
                    );
                    thinkingContent = newThinkingContent;
                  } else {
                    // 如果內容沒有增加或者是全新的內容，直接更新
                    thinkingContent = newThinkingContent;
                    updateThinkingContent(thinkingContent);
                    log(`🧠 思考內容直接更新: ${thinkingContent.length} 字符`);
                  }

                  // 如果有思考內容，打印詳情
                  if (thinkingContent && thinkingContent.length > 0) {
                    console.log("🧠 思考內容詳情:", {
                      length: thinkingContent.length,
                      preview: thinkingContent.substring(0, 200) + "...",
                    });
                  }
                }
              }

              // 處理消息內容（使用打字機效果）
              if (data.content !== undefined) {
                const newContent = data.content;
                if (newContent.length > messageContent.length) {
                  log(
                    `📝 準備打字機動畫: ${messageContent.length} → ${newContent.length}`
                  );
                  animateTyping(newContent, messageContent);
                  messageContent = newContent;
                } else {
                  messageContent = newContent;
                  updateMessageContent(messageContent);
                }
              }
              break;

            case "thinking_content_processed":
              log("🧠 思考內容處理完成");
              if (data.thinking_content) {
                thinkingContent = data.thinking_content;
                updateThinkingContent(thinkingContent);
              }
              break;

            case "stream_done":
              log("✅ 流式處理完成");
              updateStatus("流式處理完成", "connected");
              if (data.full_content) {
                messageContent = data.full_content;
                updateMessageContent(messageContent);
                log(`📝 最終內容: ${data.full_content.length} 字符`);
              }
              break;

            default:
              log(`❓ 未知事件類型: ${eventType}`);
              break;
          }
        } catch (error) {
          console.error("處理 SSE 事件錯誤:", error);
          log(`❌ 處理事件錯誤: ${error.message}`);
        }
      }

      function stopSSETest() {
        console.log("stopSSETest 被調用");
        // 移除 return，讓函數正常執行
        log("🛑 停止測試（功能暫時禁用）");
      }

      function clearLogs() {
        try {
          document.getElementById("log").innerHTML = "";
          console.log("日誌已清除");
        } catch (error) {
          console.error("清除日誌錯誤:", error);
        }
      }

      // 全局錯誤處理
      window.addEventListener("error", (event) => {
        console.error("全局錯誤:", event.error);
        log(`❌ 全局錯誤: ${event.error?.message || event.message}`);
      });

      // 防止頁面意外重載
      window.addEventListener("beforeunload", (event) => {
        console.log("頁面即將卸載");
      });
    </script>
  </body>
</html>
