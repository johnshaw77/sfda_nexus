# Chat Store 模組實現示例

## 📁 文件結構

```
frontend/src/stores/chat/
├── index.js                 # 主聚合 store
├── conversation.js          # 對話管理模組
├── message.js              # 消息管理模組
├── streaming.js            # 串流處理模組
├── tools.js                # 工具調用模組
├── models.js               # 模型管理模組
├── textConversion.js       # 文字轉換模組
└── types.js                # TypeScript 類型定義
```

## 🧩 模組實現示例

### 1. 主聚合 Store (index.js)

```javascript
/**
 * 主要聊天 Store - 聚合器模式
 * 負責協調各個子模組，提供統一的對外介面
 */
import { defineStore } from "pinia";
import { useConversationStore } from "./conversation";
import { useMessageStore } from "./message";
import { useStreamingStore } from "./streaming";
import { useToolsStore } from "./tools";
import { useModelsStore } from "./models";
import { useTextConversionStore } from "./textConversion";
import { eventBus } from "../shared/eventBus";

export const useChatStore = defineStore("chat", () => {
  // 子模組實例
  const conversationStore = useConversationStore();
  const messageStore = useMessageStore();
  const streamingStore = useStreamingStore();
  const toolsStore = useToolsStore();
  const modelsStore = useModelsStore();
  const textConversionStore = useTextConversionStore();

  // 初始化所有模組
  const initialize = async () => {
    await Promise.all([
      conversationStore.initialize(),
      modelsStore.initialize(),
      textConversionStore.initialize(),
    ]);
  };

  // 發送消息的統一入口
  const sendMessage = async (content, options = {}) => {
    try {
      // 確保有當前對話
      let conversationId = conversationStore.currentConversationId;
      if (!conversationId) {
        const conversation = await conversationStore.createConversation({
          title: options.title || "新對話",
        });
        conversationId = conversation.id;
      }

      // 開始串流發送
      return await streamingStore.sendMessageStream(
        conversationId,
        content,
        options
      );
    } catch (error) {
      console.error("發送消息失敗:", error);
      throw error;
    }
  };

  // 返回統一的介面
  return {
    // 初始化
    initialize,

    // 主要操作
    sendMessage,

    // 子模組的公開介面
    conversations: conversationStore,
    messages: messageStore,
    streaming: streamingStore,
    tools: toolsStore,
    models: modelsStore,
    textConversion: textConversionStore,
  };
});
```

### 2. 對話管理模組 (conversation.js)

```javascript
/**
 * 對話管理模組
 * 負責對話的增刪改查、選擇、置頂等功能
 */
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import api from "@/api/index.js";
import { message } from "ant-design-vue";
import { eventBus } from "../shared/eventBus";
import { usePagination } from "../shared/pagination";

export const useConversationStore = defineStore("conversation", () => {
  // 狀態
  const conversations = ref([]);
  const currentConversation = ref(null);
  const isLoading = ref(false);

  // 分頁功能
  const pagination = usePagination({
    pageSize: 20,
  });

  // 計算屬性
  const currentConversationId = computed(() => currentConversation.value?.id);
  const hasConversations = computed(() => conversations.value.length > 0);

  // 載入對話列表
  const getConversations = async (params = {}) => {
    isLoading.value = true;
    try {
      const response = await api.get("/api/chat/conversations", {
        params: {
          page: pagination.current.value,
          limit: pagination.pageSize.value,
          ...params,
        },
      });

      const { data: conversationData, pagination: paginationData } =
        response.data.data;

      conversations.value = conversationData;
      pagination.updateFromResponse(paginationData);

      // 發送事件通知
      eventBus.emit("conversations:loaded", conversationData);

      return conversationData;
    } catch (error) {
      console.error("載入對話失敗:", error);
      message.error("載入對話失敗");
      throw error;
    } finally {
      isLoading.value = false;
    }
  };

  // 創建新對話
  const createConversation = async (conversationData) => {
    isLoading.value = true;
    try {
      const response = await api.post(
        "/api/chat/conversations",
        conversationData
      );
      const newConversation = response.data.data;

      // 發送事件通知
      eventBus.emit("conversation:created", newConversation);

      return newConversation;
    } catch (error) {
      console.error("創建對話失敗:", error);
      message.error("創建對話失敗");
      throw error;
    } finally {
      isLoading.value = false;
    }
  };

  // 選擇對話
  const selectConversation = async (conversation) => {
    if (currentConversation.value?.id === conversation.id) return;

    // 離開當前對話
    if (currentConversation.value) {
      eventBus.emit("conversation:leave", currentConversation.value);
    }

    // 設置新對話
    currentConversation.value = conversation;

    // 發送事件通知
    eventBus.emit("conversation:selected", conversation);

    return conversation;
  };

  // 更新對話
  const updateConversation = async (conversationId, updates) => {
    try {
      const response = await api.put(
        `/api/chat/conversations/${conversationId}`,
        updates
      );
      const updatedConversation = response.data.data;

      // 更新列表中的對話
      const index = conversations.value.findIndex(
        (c) => c.id === conversationId
      );
      if (index !== -1) {
        conversations.value[index] = updatedConversation;
      }

      // 更新當前對話
      if (currentConversation.value?.id === conversationId) {
        currentConversation.value = updatedConversation;
      }

      eventBus.emit("conversation:updated", updatedConversation);
      return updatedConversation;
    } catch (error) {
      console.error("更新對話失敗:", error);
      message.error("更新對話失敗");
      throw error;
    }
  };

  // 刪除對話
  const deleteConversation = async (conversationId) => {
    try {
      await api.delete(`/api/chat/conversations/${conversationId}`);

      // 從列表中移除
      conversations.value = conversations.value.filter(
        (c) => c.id !== conversationId
      );

      // 如果是當前對話，清空
      if (currentConversation.value?.id === conversationId) {
        currentConversation.value = null;
        eventBus.emit("conversation:cleared");
      }

      eventBus.emit("conversation:deleted", conversationId);
      message.success("對話已刪除");
    } catch (error) {
      console.error("刪除對話失敗:", error);
      message.error("刪除對話失敗");
      throw error;
    }
  };

  // 置頂/取消置頂對話
  const togglePinConversation = async (conversationId, pinned = true) => {
    try {
      await api.post(`/api/chat/conversations/${conversationId}/pin`, {
        pinned,
      });

      // 更新對話狀態
      const conversation = conversations.value.find(
        (c) => c.id === conversationId
      );
      if (conversation) {
        conversation.is_pinned = pinned;
        sortConversations();
      }

      eventBus.emit("conversation:pin-toggled", { conversationId, pinned });
      message.success(pinned ? "對話已置頂" : "對話已取消置頂");
    } catch (error) {
      console.error("置頂操作失敗:", error);
      message.error("置頂操作失敗");
      throw error;
    }
  };

  // 排序對話
  const sortConversations = () => {
    conversations.value.sort((a, b) => {
      if (a.is_pinned && !b.is_pinned) return -1;
      if (!a.is_pinned && b.is_pinned) return 1;
      return new Date(b.last_message_at) - new Date(a.last_message_at);
    });
  };

  // 初始化
  const initialize = async () => {
    await getConversations();
  };

  return {
    // 狀態
    conversations,
    currentConversation,
    isLoading,
    pagination,

    // 計算屬性
    currentConversationId,
    hasConversations,

    // 方法
    initialize,
    getConversations,
    createConversation,
    selectConversation,
    updateConversation,
    deleteConversation,
    togglePinConversation,
    sortConversations,
  };
});
```

### 3. 串流處理模組 (streaming.js)

```javascript
/**
 * 串流處理模組
 * 負責 SSE 連接管理、事件處理、打字機動畫等
 */
import { defineStore } from "pinia";
import { ref } from "vue";
import { useConfigStore } from "../config";
import { eventBus } from "../shared/eventBus";
import { message } from "ant-design-vue";

export const useStreamingStore = defineStore("streaming", () => {
  // 狀態
  const isStreaming = ref(false);
  const streamController = ref(null);
  const streamingMessageId = ref(null);

  // 開始串流發送
  const sendMessageStream = async (conversationId, content, options = {}) => {
    try {
      isStreaming.value = true;

      // 獲取配置
      const configStore = useConfigStore();
      await configStore.ensureLoaded();

      // 創建 AbortController
      const controller = new AbortController();
      streamController.value = controller;

      // 設置超時
      const timeoutId = setTimeout(() => {
        controller.abort();
        message.warning("請求超時");
      }, 600000);

      // 準備請求
      const authToken =
        localStorage.getItem("token") || sessionStorage.getItem("token");
      const streamUrl = `${configStore.apiBaseUrl}/api/chat/conversations/${conversationId}/messages/stream`;

      const requestBody = {
        conversation_id: conversationId,
        content,
        content_type: options.content_type || "text",
        ...options,
      };

      // 發起 SSE 請求
      const response = await fetch(streamUrl, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${authToken}`,
          "Content-Type": "application/json",
          Accept: "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive",
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // 處理串流
      await processStream(response, conversationId);
    } catch (error) {
      if (error.name === "AbortError") {
        message.info("對話已停止");
      } else {
        console.error("串流發送失敗:", error);
        message.error(error.message || "串流發送失敗");
        throw error;
      }
    } finally {
      cleanup();
    }
  };

  // 處理串流響應
  const processStream = async (response, conversationId) => {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";

      let currentEventType = null;

      for (const line of lines) {
        if (line.startsWith("event: ")) {
          currentEventType = line.slice(7).trim();
        } else if (line.startsWith("data: ")) {
          const jsonStr = line.slice(6).trim();

          if (jsonStr && currentEventType) {
            try {
              const data = JSON.parse(jsonStr);
              await handleSSEEvent(currentEventType, data, conversationId);
              currentEventType = null;
            } catch (parseError) {
              console.warn("SSE 數據解析錯誤:", parseError.message);
            }
          }
        }
      }
    }
  };

  // 處理 SSE 事件
  const handleSSEEvent = async (eventType, data, conversationId) => {
    // 發送到事件總線，讓其他模組處理
    eventBus.emit(`sse:${eventType}`, { ...data, conversationId });

    // 處理串流特定的事件
    switch (eventType) {
      case "assistant_message_created":
        streamingMessageId.value = data.assistant_message_id;
        break;

      case "stream_done":
        if (streamingMessageId.value === data.assistant_message_id) {
          streamingMessageId.value = null;
        }
        cleanup();
        break;

      case "error":
        cleanup();
        throw new Error(data.error);
    }
  };

  // 停止當前串流
  const stopCurrentStream = () => {
    if (streamController.value && isStreaming.value) {
      streamController.value.abort();
    }
  };

  // 清理狀態
  const cleanup = () => {
    isStreaming.value = false;
    streamController.value = null;
  };

  return {
    // 狀態
    isStreaming,
    streamingMessageId,

    // 方法
    sendMessageStream,
    stopCurrentStream,
    handleSSEEvent,
    cleanup,
  };
});
```

### 4. 事件總線 (shared/eventBus.js)

```javascript
/**
 * 事件總線
 * 用於模組間的通信
 */
import { reactive } from "vue";

class EventBus {
  constructor() {
    this.events = reactive({});
  }

  // 監聽事件
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);

    // 返回取消監聽的函數
    return () => this.off(event, callback);
  }

  // 移除事件監聽
  off(event, callback) {
    if (!this.events[event]) return;

    const index = this.events[event].indexOf(callback);
    if (index > -1) {
      this.events[event].splice(index, 1);
    }
  }

  // 發送事件
  emit(event, data) {
    if (!this.events[event]) return;

    this.events[event].forEach((callback) => {
      try {
        callback(data);
      } catch (error) {
        console.error(`事件處理錯誤 [${event}]:`, error);
      }
    });
  }

  // 一次性監聽
  once(event, callback) {
    const wrappedCallback = (data) => {
      callback(data);
      this.off(event, wrappedCallback);
    };
    return this.on(event, wrappedCallback);
  }
}

export const eventBus = new EventBus();
```

## 🔗 模組間通信範例

### 事件驅動的通信

```javascript
// 對話模組發送事件
eventBus.emit("conversation:selected", conversation);

// 消息模組監聽事件
eventBus.on("conversation:selected", (conversation) => {
  loadMessages(conversation.id);
});

// SSE 事件廣播
eventBus.emit("sse:stream_content", data);

// 多個模組可以同時監聽
eventBus.on("sse:stream_content", (data) => {
  // 消息模組處理內容更新
});

eventBus.on("sse:stream_content", (data) => {
  // 文字轉換模組處理轉換
});
```

## ✅ 重構優勢

### 1. 程式碼組織

- **職責清晰**：每個模組只負責特定功能
- **易於維護**：修改一個功能不會影響其他模組
- **可重用性**：模組可以在其他專案中重用

### 2. 測試友善

- **單元測試**：每個模組可以獨立測試
- **模擬依賴**：通過事件總線模擬模組間通信
- **集成測試**：通過事件驗證模組協作

### 3. 開發體驗

- **並行開發**：不同開發者可以同時開發不同模組
- **漸進遷移**：可以逐步替換舊的實現
- **錯誤隔離**：一個模組的錯誤不會影響其他模組

這種模組化的設計讓整個聊天系統更加穩定、可維護，同時保持了原有的功能完整性。
